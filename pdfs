#!/bin/bash

# ==============================================================================
# Project: PDFS - PDF Screenshooter
# Description: CLI tool to clip PDF pages to clipboard or save to file.
# License: GPL
# Version: 2.0 (feat: Yay style indexing)
# ==============================================================================
#!/bin/bash

CONFIG_DIR="$HOME/.config/pdfs"
SESSION_FILE="$CONFIG_DIR/sessions.txt"
SETTINGS_FILE="$CONFIG_DIR/settings.conf"
SAVE_DIR="$HOME/Photos/pdfs"

RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

if [ ! -d "$CONFIG_DIR" ]; then mkdir -p "$CONFIG_DIR"; touch "$SESSION_FILE"; fi
if [ ! -d "$SAVE_DIR" ]; then mkdir -p "$SAVE_DIR"; fi
if [ ! -f "$SETTINGS_FILE" ]; then echo "mode=copy" > "$SETTINGS_FILE"; fi

check_deps() {
    local missing=0
    if ! command -v pdftoppm &> /dev/null; then echo -e "${RED}Missing: poppler-utils${NC}"; missing=1; fi
    if ! command -v wl-copy &> /dev/null; then echo -e "${RED}Missing: wl-clipboard${NC}"; missing=1; fi
    if ! command -v python3 &> /dev/null; then echo -e "${RED}Missing: python3${NC}"; missing=1; fi
    if [ $missing -eq 1 ]; then exit 1; fi
}

process_page() {
    local file_path="$1"
    local page_num="$2"
    local flag="$3"
    local action=""
    
    if [[ "$flag" == "-s" ]]; then action="save";
    elif [[ "$flag" == "-c" ]]; then action="copy";
    else action=$(grep "mode=" "$SETTINGS_FILE" | cut -d'=' -f2); fi

    echo -e "${BLUE}[INFO]${NC} Processing page $page_num ($action)..."

    if [[ "$action" == "copy" ]]; then
        pdftoppm -png -f "$page_num" -l "$page_num" -r 300 "$file_path" | wl-copy --type image/png
    elif [[ "$action" == "save" ]]; then
        local base_name=$(basename "$file_path" .pdf)
        local out_file="$SAVE_DIR/${base_name}_p${page_num}.png"
        pdftoppm -png -f "$page_num" -l "$page_num" -r 300 "$file_path" > "$out_file"
        echo -e "${GREEN}[OK]${NC} Saved: $out_file"
    fi
}

get_sorted_files() {
python3 -c "
import os, re
try:
    files = [f for f in os.listdir('.') if f.lower().endswith('.pdf')]
    files.sort(key=lambda x: [int(c) if c.isdigit() else c.lower() for c in re.split(r'(\d+)', x)])
    for f in files: print(f)
except: pass
"
}

work_loop() {
    local target_dir="$1"
    if [ ! -d "$target_dir" ]; then echo -e "${RED}Dir not found: $target_dir${NC}"; exit 1; fi
    target_dir=$(realpath "$target_dir")
    cd "$target_dir" || exit

    while true; do
        echo -e "\n${BLUE}=== Work Dir: $target_dir ===${NC}"
        
        mapfile -t pdf_files < <(get_sorted_files)

        if [ ${#pdf_files[@]} -eq 0 ]; then echo -e "${RED}No PDF files found.${NC}"; exit 1; fi

        echo -e "${CYAN}Available PDFs:${NC}"
        local i=1
        for f in "${pdf_files[@]}"; do
            echo -e "${GREEN}[$i]${NC} $f"
            ((i++))
        done

        echo -e "\n${YELLOW}Select Number (Exit: 'q'):${NC}"
        read -p "> " selection
        
        [[ "$selection" == "q" ]] && exit 0

        if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le "${#pdf_files[@]}" ]; then
            selected_file="${pdf_files[$((selection-1))]}"
        else
            echo -e "${RED}Invalid selection.${NC}"
            continue
        fi

        echo -e "${BLUE}Selected: $selected_file${NC}"
        
        while true; do
            echo -e "Enter Page ('q' back):"
            read -p "> " input_raw
            read -r -a input_arr <<< "$input_raw"
            page_num="${input_arr[0]}"
            flag="${input_arr[1]}"

            [[ "$page_num" == "q" ]] && break
            if [[ "$page_num" =~ ^[0-9]+$ ]]; then 
                process_page "$selected_file" "$page_num" "$flag"
            else 
                echo -e "${RED}Invalid number.${NC}"
            fi
        done
    done
}

save_session() {
    local raw_path="$*" 
    if [ ! -d "$raw_path" ]; then echo -e "${RED}Invalid path.${NC}"; exit 1; fi
    local dir_path=$(realpath "$raw_path")

    if grep -q "|$dir_path$" "$SESSION_FILE"; then work_loop "$dir_path"; return; fi
    
    next_id=0
    for ((i=1; i<=200; i++)); do if ! grep -q "^$i|" "$SESSION_FILE"; then next_id=$i; break; fi; done
    echo "$next_id|$dir_path" >> "$SESSION_FILE"
    echo -e "${GREEN}Saved: [$next_id] -> $dir_path${NC}"
    work_loop "$dir_path"
}

list_sessions() {
    if [ ! -s "$SESSION_FILE" ]; then echo -e "${YELLOW}No sessions.${NC}"; return 1; fi
    echo -e "${BLUE}=== SAVED SESSIONS ===${NC}"
    while IFS='|' read -r id path; do printf "${GREEN}[%3d]${NC} -> %s\n" "$id" "$path"; done < "$SESSION_FILE" | sort -n -k2
}

delete_session() {
    list_sessions; if [ $? -ne 0 ]; then exit 0; fi
    echo -e "\n${RED}Delete ID:${NC}"; read -p "> " del_id
    sed -i "/^$del_id|/d" "$SESSION_FILE"; echo -e "${GREEN}Done.${NC}"
}

load_menu() {
    list_sessions; if [ $? -ne 0 ]; then echo "Usage: pdfs -s [path]"; exit 0; fi
    echo -e "\n${GREEN}Select ID:${NC}"; read -p "> " sel
    path=$(grep "^$sel|" "$SESSION_FILE" | cut -d'|' -f2)
    if [ -z "$path" ]; then echo -e "${RED}Invalid.${NC}"; exit 1; else work_loop "$path"; fi
}

check_deps
case "$1" in
    "-d") delete_session ;;
    "-s") shift; save_session "$@" ;;
    "-default") 
        echo "1) Copy 2) Save"; read -p "> " c
        [ "$c" == "1" ] && echo "mode=copy" > "$SETTINGS_FILE"
        [ "$c" == "2" ] && echo "mode=save" > "$SETTINGS_FILE"
        ;;
    "-h") echo "Usage: pdfs [-s path] [-d] [-default]";;
    "") load_menu ;;
    *) if [ -d "$*" ]; then work_loop "$*"; else echo "Invalid path"; fi ;;
esac
